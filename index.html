<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Выбор профессии</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<style>
body {
    font-family: 'Segoe UI', sans-serif;
    background: linear-gradient(135deg, #1f2937, #111827);
    color: white;
    margin: 0;
    padding: 20px;
}

h1, h2 {
    text-align: center;
    margin-bottom: 5px;
}

.grid {
    display: grid;
    gap: 10px;
    justify-content: center;
}

.row-12 { grid-template-columns: repeat(12, 110px); }
.row-9  { grid-template-columns: repeat(9,  110px); margin-top: 15px; }
.row-7  { grid-template-columns: repeat(7,  110px); margin-top: 15px; }
.row-6 { grid-template-columns: repeat(6, 110px); margin-top: 15px; }
.row-3 { grid-template-columns: repeat(3, 110px); margin-top: 15px; }

.card {
    height: 140px;
    color: white;
    text-shadow: 1px 1px 2px #000;
    border-radius: 14px;
    padding: 10px;
    font-size: 12px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    cursor: grab;
    position: relative;
    box-shadow: 0 6px 15px rgba(0,0,0,0.4);
    transition: transform 0.3s ease, opacity 0.2s;
    touch-action: none;
}

.card:hover {
    transform: scale(1.05);
}

.card.selected {
    opacity: 0.6;
    transform: scale(0.92);
    box-shadow: 0 2px 8px rgba(0,0,0,0.6);
}

.rank {
    position: absolute;
    top: 6px;
    left: 8px;
    font-size: 11px;
    font-weight: bold;
    color: #ccc;
}

.code {
    font-weight: bold;
}

.dragging {
    opacity: 0.5;
}

.info-panel {
    text-align: center;
    margin: 10px 0 20px;
}

input {
    padding: 8px;
    border-radius: 6px;
    border: none;
    width: 200px;
    margin-right: 10px;
}

#selected-container {
    margin-top: 40px;
    padding-top: 20px;
    border-top: 2px dashed #666;
}

#selected-container h2 {
    color: #fbbf24;
}

/* Цвета групп */
.group-Жизненные-цели     { background: #dc2626; } /* красный */
.group-Предметы-работы    { background: #2563eb; } /* синий */
.group-Цели-работы        { background: #60a5fa; } /* голубой */
.group-Средства-работы    { background: #ea580c; } /* оранжевый */
.group-Условия-работы     { background: #16a34a; } /* зеленый */
.group-Особые-условия     { background: #eab308; } /* желтый */
.group-Способы-коммуникации { background: #7c3aed; } /* фиолетовый */

/* Mobile */
@media (max-width: 768px) {
    .grid {
        grid-template-columns: 1fr;
        justify-items: center;
    }
    .row-12, .row-9, .row-7, .row-6, .row-3 {
        grid-template-columns: 1fr;
    }
    .card {
        width: 100%;
        max-width: 300px;
        height: auto;
        min-height: 100px;
        padding: 15px;
        font-size: 14px;
    }
    input {
        width: 100%;
        margin: 0 0 10px;
    }
}
</style>
</head>
<body>

<h1>Выбор профессии</h1>
<p style="text-align: center; margin-bottom: 20px;">Проранжируй каждый список в порядке значимости.<br>Двойной клик по карточке → перенос в «Выбранные карты» (3 + 1+1+1+1+1+1)</p>

<div class="info-panel">
    <input type="text" id="participantName" placeholder="Имя участника">
</div>

<div id="container"></div>

<div id="selected-container">
    <h2>Выбранные карты</h2>
    <div id="goals-selected" class="grid row-3"></div>
    <div id="others-selected" class="grid row-6"></div>
    <p style="text-align:center; font-size:0.9em; color:#bbb; margin-top:10px;">
        Выбрано: <span id="selected-count">0</span> / максимум 9
    </p>
</div>

<button onclick="exportPDF()" style="display:block; margin:40px auto; background:#3b82f6; border:none; padding:12px 28px; border-radius:8px; color:white; font-size:15px; cursor:pointer;">
    Экспорт в PDF
</button>

<script>
const { jsPDF } = window.jspdf;
const container = document.getElementById("container");
const goalsSelected = document.getElementById("goals-selected");
const othersSelected = document.getElementById("others-selected");
const countDisplay = document.getElementById("selected-count");

let cards = ["ЦЖ-1 Нормальная жизнь: семья, дом, размеренность",

"ЦЖ-2 Большая семья: много детей, родственников, знакомых, большое хозяйство",

"ЦЖ-3 Жизнь ради идеи: научный, духовный или эстетический поиск, идейная борьба",

"ЦЖ-4 Богатство, связи, статусность, финансовые и деловые риски",

"ЦЖ-5 Жизненные радости: развлечения, путешествия, общение с друзьями",

"ЦЖ-6 Радость познания: приобщение науки, духовным и культурным ценностям",

"ЦЖ-7 Жизнь ради здоровья и красоты",

"ЦЖ-8 Власть, влияние, известность",

"ЦЖ-9 Уход в себя, отшельничество, увлечение мистикой, философией",

"ЦЖ-10 Жизнь на дивиденды",

"ЦЖ-11 Сопутствующий успех: работа и связи с богатыми, влиятельными людьми",

"ЦЖ-12 Вложения в себя и детей: получение новых знаний и навыков, развитие талантов",

"П-1 Техника",

"П-2 Информация из натурных систем (тексты, показания приборов, документы и ПО)",

"П-3 Социальные системы",

"П-4 Нервная искусство: чувства, переживания, озарения, художественные образы",

"П-5 Наука и система идей",

"П-6 Живая природа (звери, птицы, рыбы, насекомые, растения и т. д.)",

"П-7 Животные и взрослые люди",

"П-8 Дети и подростки",

"П-9 Детали, материалы, сырьё, подлежащие обработке",

"Ц-1 Оценивать, проверять, контролировать",

"Ц-2 Торговать: продажа, покупка, посредничество",

"Ц-3 Транспортировать: перемещать людей, грузы, объекты",

"Ц-4 Преобразовывать исходные материалы, реальные и виртуальные объекты, информацию",

"Ц-5 Преобразовывать человеческое сознание",

"Ц-6 Творить, изобретать, создавать новое",

"Ц-7 Организовывать людей, руководить",

"Ц-8 Оказывать услуги",

"Ц-9 Работать над собой, быть в форме",

"С-1 Ручные (посты, приборы и приспособления «золотые руки»)",

"С-2 Механические (станки, машины и другая техника)",

"С-3 Автоматические (работающие по заданной программе)",

"С-4 Компьютеры",

"С-5 Знания, способы мышления, память",

"С-6 Выразительные движения, мимика (умение вызывать доверие и уважение, быть обаятельным)",

"С-7 Творческое мышление, способность к нестандартным действиям, собственному взгляду на вещи",

"С-8 Возможности организма и органов чувств (хорошее зрение, хороший слух и т. п.)",

"С-9 Голос",

"У-1 Бытовой микроклимат (контора офис, отдел, кабинет)",

"У-2 Помещение с людьми (торговый зал, театр, учебная аудитория)",

"У-3 Разъезды, частые командировки",

"У-4 Относительная самостоятельность (возможность самому принимать решения в рамках поставленной задачи)",

"У-5 Открытый воздух работа вне помещения",

"У-6 Нестермальные условия (в воздухе, на воде и под водой, в шахте, на войне и т.п.",

"У-7 Специальные условия (режим стерильности, температуры, влажности)",

"У-8 Изысканные отношения, престижные знакомства",

"У-9 Высокая ценная зарплата, льготы",

"О-1 Честная профессия",

"О-2 Здоровая профессия, минимальная нагрузка, вредности",

"О-3 Минимальные ограничения в труде, свободный режим, отсутствие дресс-кода, возможность общения",

"О-4 Чувство полезности, повышенная ответственность (материальная, моральная, за жизнь и здоровье людей)",

"О-5 Приключения, риск, азарт",

"О-6 Возможность дополнительного заработка: чаевые, подарки",

"О-7 Тихая, спокойная работа",

"О-8 Престижная работа: уважение, самоутверждение, зависть",

"О-9 Работа в постоянном движении",

"К-1 Индивидуальный труд, минимальное общение",

"К-2 Обычный коллектив",

"К-3 Аудитории: учебные, театральные, спортивные и прочие",

"К-4 Клиенты, посетители — часто меняющиеся люди",

"К-5 Дисциплина, субординация, чёткие, регламентированные отношения и обязанности",

"К-6 Публичная работа, известность, работа на виду коллег, клиентов",

"К-7 Дистанционное, виртуальное общение",

"К-8 Небольшой коллектив в ограниченном пространстве",

"К-9 Временное общение при обращении к духовному и культурному наследию через собственные творения",
];

const groups = [
  { label: "Жизненные цели",       cards: cards.slice(0,12),  className: "group-Жизненные-цели"     },
  { label: "Предметы работы",      cards: cards.slice(12,21), className: "group-Предметы-работы"    },
  { label: "Цели работы",          cards: cards.slice(21,30), className: "group-Цели-работы"        },
  { label: "Средства работы",      cards: cards.slice(30,39), className: "group-Средства-работы"    },
  { label: "Условия работы",       cards: cards.slice(39,48), className: "group-Условия-работы"     },
  { label: "Особые условия работы",cards: cards.slice(48,57), className: "group-Особые-условия"     },
  { label: "Способы коммуникации", cards: cards.slice(57,66), className: "group-Способы-коммуникации" }
];

let selectedCards = []; // массив объектов {code, text, groupIdx}

function renderCards() {
  container.innerHTML = "";
  goalsSelected.innerHTML = "";
  othersSelected.innerHTML = "";
  selectedCards = [];
  countDisplay.textContent = "0";

  groups.forEach((group, gIdx) => {
    let label = document.createElement("h2");
    label.textContent = group.label;
    container.appendChild(label);

    let row = document.createElement("div");
    row.className = `grid ${gIdx === 0 ? "row-12" : "row-9"}`;
    
    group.cards.forEach(text => {
      createCard(row, text, group.className, gIdx);
    });
    
    container.appendChild(row);
  });

  updateRanks();
}

function createCard(parent, text, groupClass, groupIdx) {
  const card = document.createElement("div");
  card.className = `card ${groupClass}`;
  card.draggable = true;

  const codeMatch = text.match(/^[\u0410-\u042F\u0041-\u005A]+-\d+/);
  const code = codeMatch ? codeMatch[0] : '';
  const desc = text.replace(code + ' ', '');

  card.innerHTML = `<div class="rank"></div><span class="code">${code}</span><br>${desc}`;
  card.dataset.code = code;
  card.dataset.group = groupIdx;

  // Одиночный и двойной клик
  let clickTimeout;
  card.addEventListener("click", e => {
    if (e.detail === 2) {
      clearTimeout(clickTimeout);
      toggleSelected(card);
    } else if (e.detail === 1) {
      clickTimeout = setTimeout(() => {
        // здесь можно добавить логику одиночного клика, если нужно
      }, 300);
    }
  });

  // drag (оставляем как было)
  card.addEventListener("dragstart", dragStart);
  card.addEventListener("dragend",   dragEnd);
  card.addEventListener("touchstart", touchStart, {passive:false});
  card.addEventListener("touchmove",  touchMove,  {passive:false});
  card.addEventListener("touchend",   touchEnd);

  parent.appendChild(card);
}

function toggleSelected(card) {
  const code = card.dataset.code;
  const groupIdx = parseInt(card.dataset.group);
  const alreadySelected = selectedCards.some(c => c.code === code);

  if (alreadySelected) {
    // удаляем из выбранных (оригинал остается)
    const idx = selectedCards.findIndex(c => c.code === code);
    selectedCards.splice(idx, 1);
    
    // находим и удаляем клон в selected
    const selectedClone = (groupIdx === 0 ? goalsSelected : othersSelected).querySelector(`[data-code="${code}"]`);
    if (selectedClone) selectedClone.remove();

    if (groupIdx === 0) {
      sortGoals();
    } else {
      sortOthers();
    }
  } else {
    // пытаемся добавить
    if (!canAddMore(groupIdx)) return alert("Нельзя выбрать больше разрешённого количества из этой группы");

    // добавляем клон в selected
    const clone = card.cloneNode(true);
    clone.classList.add("selected");
    clone.dataset.code = code;
    clone.dataset.group = groupIdx;
    clone.querySelector(".rank").innerText = ""; // убираем ранг в selected
    clone.addEventListener("click", e => {
      if (e.detail === 2) toggleSelected(clone);
    });
    
    if (groupIdx === 0) {
      goalsSelected.appendChild(clone);
      sortGoals();
    } else {
      othersSelected.appendChild(clone);
      sortOthers();
    }

    selectedCards.push({
      code: code,
      text: `${code} ${card.innerText.replace(/#\d+\s*/, '').replace(code, '').trim()}`,
      groupIdx: groupIdx
    });
  }

  countDisplay.textContent = selectedCards.length;
  updateRanks();
}

function sortGoals() {
  const div = goalsSelected;
  const cardsArr = Array.from(div.children);
  cardsArr.sort((a, b) => {
    const numA = parseInt(a.dataset.code.split('-')[1]);
    const numB = parseInt(b.dataset.code.split('-')[1]);
    return numA - numB;
  });
  div.innerHTML = '';
  cardsArr.forEach(c => div.appendChild(c));
}

function sortOthers() {
  const div = othersSelected;
  const cardsArr = Array.from(div.children);
  cardsArr.sort((a, b) => parseInt(a.dataset.group) - parseInt(b.dataset.group));
  div.innerHTML = '';
  cardsArr.forEach(c => div.appendChild(c));
}

function canAddMore(groupIdx) {
  if (groupIdx === 0) { // Жизненные цели
    return selectedCards.filter(c => c.groupIdx === 0).length < 3;
  } else {
    return selectedCards.filter(c => c.groupIdx === groupIdx).length < 1;
  }
}

// Drag functions for desktop
function dragStart(e) {
  this.classList.add("dragging");
  e.dataTransfer.setData("text/plain", ""); // Required for Firefox
  setTimeout(() => {
    this.style.visibility = 'hidden';
  }, 0);
}

function dragEnd() {
  this.classList.remove("dragging");
  this.style.visibility = '';
  updateOrder();
  updateRanks();
}

// Touch variables
let touchMoved = false;
let touchElem = null;
let initialX = 0;
let initialY = 0;
let ghostElem = null;
let lastClientX = 0;
let lastClientY = 0;
let isDragging = false;

// Touch functions for mobile
function touchStart(e) {
  if (e.touches.length !== 1) return;
  touchElem = this;
  touchMoved = false;
  initialX = e.touches[0].clientX - this.getBoundingClientRect().left;
  initialY = e.touches[0].clientY - this.getBoundingClientRect().top;
  lastClientX = e.touches[0].clientX;
  lastClientY = e.touches[0].clientY;
  this.classList.add("dragging");
  this.style.visibility = 'hidden';

  // Create ghost element for visual feedback
  ghostElem = this.cloneNode(true);
  ghostElem.style.position = "absolute";
  ghostElem.style.zIndex = 1000;
  ghostElem.style.opacity = 0.5;
  ghostElem.classList.remove("dragging");
  document.body.appendChild(ghostElem);
  moveGhost(e.touches[0]);

  isDragging = true;
  requestAnimationFrame(autoScroll);
}

function touchMove(e) {
  if (!touchElem || e.touches.length !== 1) return;
  e.preventDefault();
  touchMoved = true;
  lastClientX = e.touches[0].clientX;
  lastClientY = e.touches[0].clientY;
  moveGhost(e.touches[0]);

  const clientX = e.touches[0].clientX;
  const clientY = e.touches[0].clientY;
  reorderWithAnimation(touchElem, clientX, clientY);
}

function touchEnd(e) {
  if (!touchElem) return;
  if (ghostElem) {
    document.body.removeChild(ghostElem);
    ghostElem = null;
  }
  touchElem.classList.remove("dragging");
  touchElem.style.visibility = '';
  if (touchMoved) {
    updateOrder();
    updateRanks();
  }
  isDragging = false;
  touchElem = null;
}

function moveGhost(touch) {
  if (ghostElem) {
    ghostElem.style.left = `${touch.clientX - initialX}px`;
    ghostElem.style.top = `${touch.clientY - initialY}px`;
  }
}

function autoScroll() {
  if (!isDragging) return;

  const viewportHeight = window.innerHeight;
  const touchY = lastClientY;
  let scrollAmount = 0;
  const edgeSize = 100;
  const maxSpeed = 30;

  if (touchY < edgeSize) {
    scrollAmount = -((edgeSize - touchY) / edgeSize * maxSpeed);
  } else if (touchY > viewportHeight - edgeSize) {
    scrollAmount = ((touchY - (viewportHeight - edgeSize)) / edgeSize * maxSpeed);
  }

  if (scrollAmount !== 0) {
    window.scrollBy(0, scrollAmount);
    reorderWithAnimation(touchElem, lastClientX, lastClientY);
    touchMoved = true;
  }

  requestAnimationFrame(autoScroll);
}

// Dragover for desktop
document.addEventListener("dragover", e => {
  e.preventDefault();
  const dragging = document.querySelector(".dragging");
  if (!dragging) return;

  const clientX = e.clientX;
  const clientY = e.clientY;
  reorderWithAnimation(dragging, clientX, clientY);
});

// Reorder with animation function
function reorderWithAnimation(dragging, clientX, clientY) {
  const srcRow = dragging.parentElement;
  const targetGrid = dragging.parentElement; // Assume same grid, as cross not allowed

  if (!targetGrid) return;

  // Get current cards except dragging
  const cardsDOM = [...targetGrid.children].filter(c => c !== dragging && c.classList.contains('card'));
  const cards = cardsDOM.map(c => ({card: c, rect: c.getBoundingClientRect()}));

  // Record old rects
  const oldRects = cards.map(({card, rect}) => ({card, rect}));

  // Determine if horizontal or vertical
  const firstTwo = cards.slice(0, 2);
  const isHorizontal = firstTwo.length < 2 || Math.abs(firstTwo[0].rect.top - firstTwo[1].rect.top) < 1;

  // Find nextCard
  const nextCard = cards.find(({card, rect}) => {
    return isHorizontal ? clientX <= rect.left + rect.width / 2 : clientY <= rect.top + rect.height / 2;
  })?.card || null;

  // Reorder
  if (nextCard) {
    targetGrid.insertBefore(dragging, nextCard);
  } else {
    targetGrid.appendChild(dragging);
  }

  // Now animate the non-dragging cards
  oldRects.forEach(({card, rect}) => {
    const newRect = card.getBoundingClientRect();
    const deltaX = rect.left - newRect.left;
    const deltaY = rect.top - newRect.top;

    card.style.transition = 'none';
    card.style.transform = `translate(${deltaX}px, ${deltaY}px)`;

    requestAnimationFrame(() => {
      card.style.transition = 'transform 0.3s ease';
      card.style.transform = '';
    });
  });
}

function updateOrder() {
  const rows = container.querySelectorAll(".grid");
  groups.forEach((group, gIdx) => {
    const row = rows[gIdx];
    const allCardsInRow = row.querySelectorAll(".card");
    group.cards = Array.from(allCardsInRow).map(card => {
      const code = card.querySelector(".code")?.textContent || "";
      const desc = card.innerText.replace(/#\d+\s*/, '').replace(code, '').trim();
      return `${code} ${desc}`.trim();
    }).filter(Boolean);
  });
}

function updateRanks() {
  const rows = container.querySelectorAll(".grid");
  rows.forEach(row => {
    const cardsInRow = row.querySelectorAll(".card");
    cardsInRow.forEach((card, idx) => {
      card.querySelector(".rank").innerText = "#" + (idx + 1);
    });
  });
}

function exportPDF() {
  const name = document.getElementById("participantName").value.trim() || "default";
  const fileName = `${name}-professions-ranking.pdf`;

  const tempContainer = document.createElement('div');
  tempContainer.style.position = 'absolute';
  tempContainer.style.left = '-9999px';
  tempContainer.style.background = 'linear-gradient(135deg, #1f2937, #111827)';
  tempContainer.style.padding = '20px';
  tempContainer.style.color = 'white';
  tempContainer.style.width = '1200px'; // Wider to avoid mobile media query
  document.body.appendChild(tempContainer);

  const title = document.createElement('h1');
  title.textContent = 'Выбор профессии';
  title.style.textAlign = 'center';
  tempContainer.appendChild(title);

  const instruction = document.createElement('p');
  instruction.textContent = 'Проранжируй каждый список в порядке значимости';
  instruction.style.textAlign = 'center';
  instruction.style.marginBottom = '20px';
  tempContainer.appendChild(instruction);

  const rows = container.querySelectorAll('.grid');
  groups.forEach((group, gIdx) => {
    const labelElem = document.createElement("h2");
    labelElem.textContent = group.label;
    labelElem.style.textAlign = "center";
    tempContainer.appendChild(labelElem);

    const row = rows[gIdx];
    const cardsInRow = row.querySelectorAll(".card");
    const top3Cards = Array.from(cardsInRow).slice(0, 3);

    const tempRow = document.createElement("div");
    tempRow.className = "grid row-3";
    tempRow.style.gridTemplateColumns = "repeat(3, 110px)";
    tempRow.style.marginTop = "15px";

    top3Cards.forEach(card => {
      const clonedCard = card.cloneNode(true);
      // Reset mobile styles for PDF
      clonedCard.style.width = '';
      clonedCard.style.maxWidth = '';
      clonedCard.style.height = '140px';
      clonedCard.style.minHeight = '';
      clonedCard.style.padding = '10px';
      clonedCard.style.fontSize = '12px';
      tempRow.appendChild(clonedCard);
    });

    tempContainer.appendChild(tempRow);
  });

  // Добавляем выбранные карты в PDF
  const selectedLabel = document.createElement("h2");
  selectedLabel.textContent = "Выбранные карты";
  selectedLabel.style.textAlign = "center";
  tempContainer.appendChild(selectedLabel);

  // Goals row
  const tempGoalsRow = document.createElement("div");
  tempGoalsRow.className = "grid row-3";
  tempGoalsRow.style.gridTemplateColumns = "repeat(3, 110px)";
  tempGoalsRow.style.marginTop = "15px";

  goalsSelected.querySelectorAll(".card").forEach(card => {
    const clonedCard = card.cloneNode(true);
    clonedCard.style.width = '';
    clonedCard.style.maxWidth = '';
    clonedCard.style.height = '140px';
    clonedCard.style.minHeight = '';
    clonedCard.style.padding = '10px';
    clonedCard.style.fontSize = '12px';
    clonedCard.classList.remove("selected");
    clonedCard.querySelector(".rank").innerText = "";
    tempGoalsRow.appendChild(clonedCard);
  });

  tempContainer.appendChild(tempGoalsRow);

  // Others row
  const tempOthersRow = document.createElement("div");
  tempOthersRow.className = "grid row-6";
  tempOthersRow.style.gridTemplateColumns = "repeat(6, 110px)";
  tempOthersRow.style.marginTop = "15px";

  othersSelected.querySelectorAll(".card").forEach(card => {
    const clonedCard = card.cloneNode(true);
    clonedCard.style.width = '';
    clonedCard.style.maxWidth = '';
    clonedCard.style.height = '140px';
    clonedCard.style.minHeight = '';
    clonedCard.style.padding = '10px';
    clonedCard.style.fontSize = '12px';
    clonedCard.classList.remove("selected");
    clonedCard.querySelector(".rank").innerText = "";
    tempOthersRow.appendChild(clonedCard);
  });

  tempContainer.appendChild(tempOthersRow);

  html2canvas(tempContainer, { scale: 2 }).then(canvas => {
    const pdf = new jsPDF('l', 'mm', 'a4');
    const pdfWidth = pdf.internal.pageSize.getWidth();
    const pdfHeight = pdf.internal.pageSize.getHeight();
    const imgWidth = pdfWidth;
    const imgHeight = canvas.height * imgWidth / canvas.width;
    let heightLeft = imgHeight;
    let offsetY = 0;
    const ratio = imgWidth / canvas.width;

    while (heightLeft > 0) {
      const pageHeightInPdf = Math.min(pdfHeight, heightLeft);
      const srcHeight = pageHeightInPdf / ratio;

      const pageCanvas = document.createElement('canvas');
      pageCanvas.width = canvas.width;
      pageCanvas.height = srcHeight;
      const ctx = pageCanvas.getContext('2d');
      ctx.drawImage(canvas, 0, offsetY, canvas.width, srcHeight, 0, 0, canvas.width, srcHeight);

      const pageImgData = pageCanvas.toDataURL('image/png');
      pdf.addImage(pageImgData, 'PNG', 0, 0, imgWidth, pageHeightInPdf);

      offsetY += srcHeight;
      heightLeft -= pageHeightInPdf;

      if (heightLeft > 0) {
        pdf.addPage();
      }
    }

    pdf.save(fileName);
    document.body.removeChild(tempContainer);
  });
}

renderCards();
</script>

</body>
</html>
